// Generated by Selenium IDE
const { Builder, By, until } = require('selenium-webdriver');
const chrome = require('selenium-webdriver/chrome');
const BASE_URL = process.env.BASE_URL || "http://localhost:3000";

describe('paginaprincipaltest', function () {
  this.timeout(30000); // Tiempo máximo para cada test
  let driver;

  beforeEach(async function () {
    const options = new chrome.Options();
    // Eliminar --headless si quieres ver lo que sucede en CI
    // options.addArguments('--headless'); // Comentar esta línea si necesitas ver el navegador en CI
    options.addArguments('--disable-gpu'); // Necesario en entornos CI
    options.addArguments('--no-sandbox'); // Previene problemas de permisos
    options.addArguments('--disable-dev-shm-usage'); // Previene errores de memoria compartida
    options.addArguments('--ignore-certificate-errors'); // Ignorar errores de certificados
    options.addArguments('--allow-insecure-localhost'); // Permitir localhost inseguro

    driver = await new Builder()
      .forBrowser('chrome')
      .setChromeOptions(options)
      .build();
  });

  afterEach(async function () {
    if (driver) {
      await driver.quit();
    }
  });

  it('paginaprincipaltest', async function () {
    await driver.get(`${BASE_URL}/`);
    await driver.manage().window().setRect({ width: 1382, height: 736 });

    // Esperar a que la página cargue productos antes de interactuar
    await driver.wait(until.elementLocated(By.css(".producto")), 30000);  // Esperar a que aparezca al menos un producto

    // Interactuar con los elementos
    await clickWhenVisible(driver, By.css(".producto:nth-child(1) .producto-agregar"), 30000);
    await clickWhenVisible(driver, By.css(".producto:nth-child(3) .producto-agregar"), 30000);
    await clickWhenVisible(driver, By.css(".producto:nth-child(11) .producto-agregar"), 30000);
    await clickWhenVisible(driver, By.css(".producto:nth-child(14) .producto-agregar"), 30000);

    // Navegar entre secciones
    await clickWhenVisible(driver, By.css("li:nth-child(2) > .boton-menu"), 30000);
    await clickWhenVisible(driver, By.css(".producto:nth-child(2) .producto-agregar"), 30000);

    await clickWhenVisible(driver, By.css("li:nth-child(3) > .boton-menu"), 30000);
    await clickWhenVisible(driver, By.css(".producto:nth-child(5) .producto-agregar"), 30000);

    await clickWhenVisible(driver, By.css("li:nth-child(4) > .boton-menu"), 30000);
    await clickWhenVisible(driver, By.css(".producto:nth-child(3) .producto-agregar"), 30000);
  });
});

// Función auxiliar para hacer clic cuando el elemento esté visible
async function clickWhenVisible(driver, locator, timeout = 30000) {
  await driver.wait(until.elementLocated(locator), timeout);
  
  const element = await driver.findElement(locator);
  
  // Asegurarse de que el elemento esté visible y actualizado
  await driver.wait(until.elementIsVisible(element), timeout);

  // Desplazar el elemento al centro de la pantalla
  await driver.executeScript("arguments[0].scrollIntoView({block: 'center', inline: 'center'});", element);

  // Verificar si el elemento no está bloqueado
  await driver.wait(async () => {
    const isClickable = await driver.executeScript(`
      var el = arguments[0];
      var rect = el.getBoundingClientRect();
      var x = rect.left + rect.width / 2;
      var y = rect.top + rect.height / 2;
      return document.elementFromPoint(x, y) === el;
    `, element);
    return isClickable;
  }, timeout, "Elemento bloqueado por otro elemento.");

  // Intentar hacer clic
  try {
    await element.click();
  } catch (error) {
    if (error.name === 'StaleElementReferenceError') {
      // Si el elemento se vuelve obsoleto, localizarlo de nuevo
      const freshElement = await driver.findElement(locator);
      await freshElement.click();
    } else {
      throw error;
    }
  }
}
